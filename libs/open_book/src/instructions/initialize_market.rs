//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;
use borsh::BorshSerialize;

/// Accounts.
#[derive(Debug)]
pub struct InitializeMarket {
    /// the market to initialize
    pub market_to_initialize: solana_pubkey::Pubkey,
    /// zeroed out request queue
    pub request_queue: solana_pubkey::Pubkey,
    /// zeroed out event queue
    pub event_queue: solana_pubkey::Pubkey,
    /// zeroed out bids
    pub bids: solana_pubkey::Pubkey,
    /// zeroed out asks
    pub asks: solana_pubkey::Pubkey,
    /// spl-token account for the coin currency
    pub spl_token_account_coin: solana_pubkey::Pubkey,
    /// spl-token account for the price currency
    pub spl_token_account_price: solana_pubkey::Pubkey,
    /// coin currency Mint
    pub coin_currency_mint: solana_pubkey::Pubkey,
    /// price currency Mint
    pub price_currency_mint: solana_pubkey::Pubkey,
    /// the rent sysvar
    pub rent_sysvar: solana_pubkey::Pubkey,
    /// open orders market authority (optional)
    pub open_orders_market_authority: Option<solana_pubkey::Pubkey>,
    /// prune authority (optional, requires open orders market authority)
    pub prune_authority: Option<solana_pubkey::Pubkey>,
    /// crank authority (optional, requires prune authority)
    pub crank_authority: Option<solana_pubkey::Pubkey>,
}

impl InitializeMarket {
    pub fn instruction(
        &self,
        args: InitializeMarketInstructionArgs,
    ) -> solana_instruction::Instruction {
        self.instruction_with_remaining_accounts(args, &[])
    }
    #[allow(clippy::arithmetic_side_effects)]
    #[allow(clippy::vec_init_then_push)]
    pub fn instruction_with_remaining_accounts(
        &self,
        args: InitializeMarketInstructionArgs,
        remaining_accounts: &[solana_instruction::AccountMeta],
    ) -> solana_instruction::Instruction {
        let mut accounts = Vec::with_capacity(13 + remaining_accounts.len());
        accounts.push(solana_instruction::AccountMeta::new(
            self.market_to_initialize,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(
            self.request_queue,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(
            self.event_queue,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(self.bids, false));
        accounts.push(solana_instruction::AccountMeta::new(self.asks, false));
        accounts.push(solana_instruction::AccountMeta::new(
            self.spl_token_account_coin,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(
            self.spl_token_account_price,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new_readonly(
            self.coin_currency_mint,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new_readonly(
            self.price_currency_mint,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new_readonly(
            self.rent_sysvar,
            false,
        ));
        if let Some(open_orders_market_authority) = self.open_orders_market_authority {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                open_orders_market_authority,
                false,
            ));
        } else {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crate::OPEN_BOOK_DEX_ID,
                false,
            ));
        }
        if let Some(prune_authority) = self.prune_authority {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                prune_authority,
                false,
            ));
        } else {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crate::OPEN_BOOK_DEX_ID,
                false,
            ));
        }
        if let Some(crank_authority) = self.crank_authority {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crank_authority,
                false,
            ));
        } else {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crate::OPEN_BOOK_DEX_ID,
                false,
            ));
        }
        accounts.extend_from_slice(remaining_accounts);
        let mut data = borsh::to_vec(&InitializeMarketInstructionData::new()).unwrap();
        let mut args = borsh::to_vec(&args).unwrap();
        data.append(&mut args);

        solana_instruction::Instruction {
            program_id: crate::OPEN_BOOK_DEX_ID,
            accounts,
            data,
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeMarketInstructionData {
    discriminator: [u8; 8],
}

impl InitializeMarketInstructionData {
    pub fn new() -> Self {
        Self {
            discriminator: [35, 35, 189, 193, 155, 48, 170, 203],
        }
    }
}

impl Default for InitializeMarketInstructionData {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InitializeMarketInstructionArgs {
    pub coin_lot_size: u64,
    pub pc_lot_size: u64,
    pub fee_rate_bps: u16,
    pub vault_signer_nonce: u64,
    pub pc_dust_threshold: u64,
}

/// Instruction builder for `InitializeMarket`.
///
/// ### Accounts:
///
///   0. `[writable]` market_to_initialize
///   1. `[writable]` request_queue
///   2. `[writable]` event_queue
///   3. `[writable]` bids
///   4. `[writable]` asks
///   5. `[writable]` spl_token_account_coin
///   6. `[writable]` spl_token_account_price
///   7. `[]` coin_currency_mint
///   8. `[]` price_currency_mint
///   9. `[optional]` rent_sysvar (default to `SysvarRent111111111111111111111111111111111`)
///   10. `[optional]` open_orders_market_authority
///   11. `[optional]` prune_authority
///   12. `[optional]` crank_authority
#[derive(Clone, Debug, Default)]
pub struct InitializeMarketBuilder {
    market_to_initialize: Option<solana_pubkey::Pubkey>,
    request_queue: Option<solana_pubkey::Pubkey>,
    event_queue: Option<solana_pubkey::Pubkey>,
    bids: Option<solana_pubkey::Pubkey>,
    asks: Option<solana_pubkey::Pubkey>,
    spl_token_account_coin: Option<solana_pubkey::Pubkey>,
    spl_token_account_price: Option<solana_pubkey::Pubkey>,
    coin_currency_mint: Option<solana_pubkey::Pubkey>,
    price_currency_mint: Option<solana_pubkey::Pubkey>,
    rent_sysvar: Option<solana_pubkey::Pubkey>,
    open_orders_market_authority: Option<solana_pubkey::Pubkey>,
    prune_authority: Option<solana_pubkey::Pubkey>,
    crank_authority: Option<solana_pubkey::Pubkey>,
    coin_lot_size: Option<u64>,
    pc_lot_size: Option<u64>,
    fee_rate_bps: Option<u16>,
    vault_signer_nonce: Option<u64>,
    pc_dust_threshold: Option<u64>,
    __remaining_accounts: Vec<solana_instruction::AccountMeta>,
}

impl InitializeMarketBuilder {
    pub fn new() -> Self {
        Self::default()
    }
    /// the market to initialize
    #[inline(always)]
    pub fn market_to_initialize(
        &mut self,
        market_to_initialize: solana_pubkey::Pubkey,
    ) -> &mut Self {
        self.market_to_initialize = Some(market_to_initialize);
        self
    }
    /// zeroed out request queue
    #[inline(always)]
    pub fn request_queue(&mut self, request_queue: solana_pubkey::Pubkey) -> &mut Self {
        self.request_queue = Some(request_queue);
        self
    }
    /// zeroed out event queue
    #[inline(always)]
    pub fn event_queue(&mut self, event_queue: solana_pubkey::Pubkey) -> &mut Self {
        self.event_queue = Some(event_queue);
        self
    }
    /// zeroed out bids
    #[inline(always)]
    pub fn bids(&mut self, bids: solana_pubkey::Pubkey) -> &mut Self {
        self.bids = Some(bids);
        self
    }
    /// zeroed out asks
    #[inline(always)]
    pub fn asks(&mut self, asks: solana_pubkey::Pubkey) -> &mut Self {
        self.asks = Some(asks);
        self
    }
    /// spl-token account for the coin currency
    #[inline(always)]
    pub fn spl_token_account_coin(
        &mut self,
        spl_token_account_coin: solana_pubkey::Pubkey,
    ) -> &mut Self {
        self.spl_token_account_coin = Some(spl_token_account_coin);
        self
    }
    /// spl-token account for the price currency
    #[inline(always)]
    pub fn spl_token_account_price(
        &mut self,
        spl_token_account_price: solana_pubkey::Pubkey,
    ) -> &mut Self {
        self.spl_token_account_price = Some(spl_token_account_price);
        self
    }
    /// coin currency Mint
    #[inline(always)]
    pub fn coin_currency_mint(&mut self, coin_currency_mint: solana_pubkey::Pubkey) -> &mut Self {
        self.coin_currency_mint = Some(coin_currency_mint);
        self
    }
    /// price currency Mint
    #[inline(always)]
    pub fn price_currency_mint(&mut self, price_currency_mint: solana_pubkey::Pubkey) -> &mut Self {
        self.price_currency_mint = Some(price_currency_mint);
        self
    }
    /// `[optional account, default to 'SysvarRent111111111111111111111111111111111']`
    /// the rent sysvar
    #[inline(always)]
    pub fn rent_sysvar(&mut self, rent_sysvar: solana_pubkey::Pubkey) -> &mut Self {
        self.rent_sysvar = Some(rent_sysvar);
        self
    }
    /// `[optional account]`
    /// open orders market authority (optional)
    #[inline(always)]
    pub fn open_orders_market_authority(
        &mut self,
        open_orders_market_authority: Option<solana_pubkey::Pubkey>,
    ) -> &mut Self {
        self.open_orders_market_authority = open_orders_market_authority;
        self
    }
    /// `[optional account]`
    /// prune authority (optional, requires open orders market authority)
    #[inline(always)]
    pub fn prune_authority(&mut self, prune_authority: Option<solana_pubkey::Pubkey>) -> &mut Self {
        self.prune_authority = prune_authority;
        self
    }
    /// `[optional account]`
    /// crank authority (optional, requires prune authority)
    #[inline(always)]
    pub fn crank_authority(&mut self, crank_authority: Option<solana_pubkey::Pubkey>) -> &mut Self {
        self.crank_authority = crank_authority;
        self
    }
    #[inline(always)]
    pub fn coin_lot_size(&mut self, coin_lot_size: u64) -> &mut Self {
        self.coin_lot_size = Some(coin_lot_size);
        self
    }
    #[inline(always)]
    pub fn pc_lot_size(&mut self, pc_lot_size: u64) -> &mut Self {
        self.pc_lot_size = Some(pc_lot_size);
        self
    }
    #[inline(always)]
    pub fn fee_rate_bps(&mut self, fee_rate_bps: u16) -> &mut Self {
        self.fee_rate_bps = Some(fee_rate_bps);
        self
    }
    #[inline(always)]
    pub fn vault_signer_nonce(&mut self, vault_signer_nonce: u64) -> &mut Self {
        self.vault_signer_nonce = Some(vault_signer_nonce);
        self
    }
    #[inline(always)]
    pub fn pc_dust_threshold(&mut self, pc_dust_threshold: u64) -> &mut Self {
        self.pc_dust_threshold = Some(pc_dust_threshold);
        self
    }
    /// Add an additional account to the instruction.
    #[inline(always)]
    pub fn add_remaining_account(&mut self, account: solana_instruction::AccountMeta) -> &mut Self {
        self.__remaining_accounts.push(account);
        self
    }
    /// Add additional accounts to the instruction.
    #[inline(always)]
    pub fn add_remaining_accounts(
        &mut self,
        accounts: &[solana_instruction::AccountMeta],
    ) -> &mut Self {
        self.__remaining_accounts.extend_from_slice(accounts);
        self
    }
    #[allow(clippy::clone_on_copy)]
    pub fn instruction(&self) -> solana_instruction::Instruction {
        let accounts = InitializeMarket {
            market_to_initialize: self
                .market_to_initialize
                .expect("market_to_initialize is not set"),
            request_queue: self.request_queue.expect("request_queue is not set"),
            event_queue: self.event_queue.expect("event_queue is not set"),
            bids: self.bids.expect("bids is not set"),
            asks: self.asks.expect("asks is not set"),
            spl_token_account_coin: self
                .spl_token_account_coin
                .expect("spl_token_account_coin is not set"),
            spl_token_account_price: self
                .spl_token_account_price
                .expect("spl_token_account_price is not set"),
            coin_currency_mint: self
                .coin_currency_mint
                .expect("coin_currency_mint is not set"),
            price_currency_mint: self
                .price_currency_mint
                .expect("price_currency_mint is not set"),
            rent_sysvar: self.rent_sysvar.unwrap_or(solana_pubkey::pubkey!(
                "SysvarRent111111111111111111111111111111111"
            )),
            open_orders_market_authority: self.open_orders_market_authority,
            prune_authority: self.prune_authority,
            crank_authority: self.crank_authority,
        };
        let args = InitializeMarketInstructionArgs {
            coin_lot_size: self
                .coin_lot_size
                .clone()
                .expect("coin_lot_size is not set"),
            pc_lot_size: self.pc_lot_size.clone().expect("pc_lot_size is not set"),
            fee_rate_bps: self.fee_rate_bps.clone().expect("fee_rate_bps is not set"),
            vault_signer_nonce: self
                .vault_signer_nonce
                .clone()
                .expect("vault_signer_nonce is not set"),
            pc_dust_threshold: self
                .pc_dust_threshold
                .clone()
                .expect("pc_dust_threshold is not set"),
        };

        accounts.instruction_with_remaining_accounts(args, &self.__remaining_accounts)
    }
}

/// `initialize_market` CPI accounts.
pub struct InitializeMarketCpiAccounts<'a, 'b> {
    /// the market to initialize
    pub market_to_initialize: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out request queue
    pub request_queue: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out event queue
    pub event_queue: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out bids
    pub bids: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out asks
    pub asks: &'b solana_account_info::AccountInfo<'a>,
    /// spl-token account for the coin currency
    pub spl_token_account_coin: &'b solana_account_info::AccountInfo<'a>,
    /// spl-token account for the price currency
    pub spl_token_account_price: &'b solana_account_info::AccountInfo<'a>,
    /// coin currency Mint
    pub coin_currency_mint: &'b solana_account_info::AccountInfo<'a>,
    /// price currency Mint
    pub price_currency_mint: &'b solana_account_info::AccountInfo<'a>,
    /// the rent sysvar
    pub rent_sysvar: &'b solana_account_info::AccountInfo<'a>,
    /// open orders market authority (optional)
    pub open_orders_market_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    /// prune authority (optional, requires open orders market authority)
    pub prune_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    /// crank authority (optional, requires prune authority)
    pub crank_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
}

/// `initialize_market` CPI instruction.
pub struct InitializeMarketCpi<'a, 'b> {
    /// The program to invoke.
    pub __program: &'b solana_account_info::AccountInfo<'a>,
    /// the market to initialize
    pub market_to_initialize: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out request queue
    pub request_queue: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out event queue
    pub event_queue: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out bids
    pub bids: &'b solana_account_info::AccountInfo<'a>,
    /// zeroed out asks
    pub asks: &'b solana_account_info::AccountInfo<'a>,
    /// spl-token account for the coin currency
    pub spl_token_account_coin: &'b solana_account_info::AccountInfo<'a>,
    /// spl-token account for the price currency
    pub spl_token_account_price: &'b solana_account_info::AccountInfo<'a>,
    /// coin currency Mint
    pub coin_currency_mint: &'b solana_account_info::AccountInfo<'a>,
    /// price currency Mint
    pub price_currency_mint: &'b solana_account_info::AccountInfo<'a>,
    /// the rent sysvar
    pub rent_sysvar: &'b solana_account_info::AccountInfo<'a>,
    /// open orders market authority (optional)
    pub open_orders_market_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    /// prune authority (optional, requires open orders market authority)
    pub prune_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    /// crank authority (optional, requires prune authority)
    pub crank_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    /// The arguments for the instruction.
    pub __args: InitializeMarketInstructionArgs,
}

impl<'a, 'b> InitializeMarketCpi<'a, 'b> {
    pub fn new(
        program: &'b solana_account_info::AccountInfo<'a>,
        accounts: InitializeMarketCpiAccounts<'a, 'b>,
        args: InitializeMarketInstructionArgs,
    ) -> Self {
        Self {
            __program: program,
            market_to_initialize: accounts.market_to_initialize,
            request_queue: accounts.request_queue,
            event_queue: accounts.event_queue,
            bids: accounts.bids,
            asks: accounts.asks,
            spl_token_account_coin: accounts.spl_token_account_coin,
            spl_token_account_price: accounts.spl_token_account_price,
            coin_currency_mint: accounts.coin_currency_mint,
            price_currency_mint: accounts.price_currency_mint,
            rent_sysvar: accounts.rent_sysvar,
            open_orders_market_authority: accounts.open_orders_market_authority,
            prune_authority: accounts.prune_authority,
            crank_authority: accounts.crank_authority,
            __args: args,
        }
    }
    #[inline(always)]
    pub fn invoke(&self) -> solana_program_entrypoint::ProgramResult {
        self.invoke_signed_with_remaining_accounts(&[], &[])
    }
    #[inline(always)]
    pub fn invoke_with_remaining_accounts(
        &self,
        remaining_accounts: &[(&'b solana_account_info::AccountInfo<'a>, bool, bool)],
    ) -> solana_program_entrypoint::ProgramResult {
        self.invoke_signed_with_remaining_accounts(&[], remaining_accounts)
    }
    #[inline(always)]
    pub fn invoke_signed(
        &self,
        signers_seeds: &[&[&[u8]]],
    ) -> solana_program_entrypoint::ProgramResult {
        self.invoke_signed_with_remaining_accounts(signers_seeds, &[])
    }
    #[allow(clippy::arithmetic_side_effects)]
    #[allow(clippy::clone_on_copy)]
    #[allow(clippy::vec_init_then_push)]
    pub fn invoke_signed_with_remaining_accounts(
        &self,
        signers_seeds: &[&[&[u8]]],
        remaining_accounts: &[(&'b solana_account_info::AccountInfo<'a>, bool, bool)],
    ) -> solana_program_entrypoint::ProgramResult {
        let mut accounts = Vec::with_capacity(13 + remaining_accounts.len());
        accounts.push(solana_instruction::AccountMeta::new(
            *self.market_to_initialize.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(
            *self.request_queue.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(
            *self.event_queue.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(*self.bids.key, false));
        accounts.push(solana_instruction::AccountMeta::new(*self.asks.key, false));
        accounts.push(solana_instruction::AccountMeta::new(
            *self.spl_token_account_coin.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new(
            *self.spl_token_account_price.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new_readonly(
            *self.coin_currency_mint.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new_readonly(
            *self.price_currency_mint.key,
            false,
        ));
        accounts.push(solana_instruction::AccountMeta::new_readonly(
            *self.rent_sysvar.key,
            false,
        ));
        if let Some(open_orders_market_authority) = self.open_orders_market_authority {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                *open_orders_market_authority.key,
                false,
            ));
        } else {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crate::OPEN_BOOK_DEX_ID,
                false,
            ));
        }
        if let Some(prune_authority) = self.prune_authority {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                *prune_authority.key,
                false,
            ));
        } else {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crate::OPEN_BOOK_DEX_ID,
                false,
            ));
        }
        if let Some(crank_authority) = self.crank_authority {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                *crank_authority.key,
                false,
            ));
        } else {
            accounts.push(solana_instruction::AccountMeta::new_readonly(
                crate::OPEN_BOOK_DEX_ID,
                false,
            ));
        }
        remaining_accounts.iter().for_each(|remaining_account| {
            accounts.push(solana_instruction::AccountMeta {
                pubkey: *remaining_account.0.key,
                is_signer: remaining_account.1,
                is_writable: remaining_account.2,
            })
        });
        let mut data = borsh::to_vec(&InitializeMarketInstructionData::new()).unwrap();
        let mut args = borsh::to_vec(&self.__args).unwrap();
        data.append(&mut args);

        let instruction = solana_instruction::Instruction {
            program_id: crate::OPEN_BOOK_DEX_ID,
            accounts,
            data,
        };
        let mut account_infos = Vec::with_capacity(14 + remaining_accounts.len());
        account_infos.push(self.__program.clone());
        account_infos.push(self.market_to_initialize.clone());
        account_infos.push(self.request_queue.clone());
        account_infos.push(self.event_queue.clone());
        account_infos.push(self.bids.clone());
        account_infos.push(self.asks.clone());
        account_infos.push(self.spl_token_account_coin.clone());
        account_infos.push(self.spl_token_account_price.clone());
        account_infos.push(self.coin_currency_mint.clone());
        account_infos.push(self.price_currency_mint.clone());
        account_infos.push(self.rent_sysvar.clone());
        if let Some(open_orders_market_authority) = self.open_orders_market_authority {
            account_infos.push(open_orders_market_authority.clone());
        }
        if let Some(prune_authority) = self.prune_authority {
            account_infos.push(prune_authority.clone());
        }
        if let Some(crank_authority) = self.crank_authority {
            account_infos.push(crank_authority.clone());
        }
        remaining_accounts
            .iter()
            .for_each(|remaining_account| account_infos.push(remaining_account.0.clone()));

        if signers_seeds.is_empty() {
            solana_cpi::invoke(&instruction, &account_infos)
        } else {
            solana_cpi::invoke_signed(&instruction, &account_infos, signers_seeds)
        }
    }
}

/// Instruction builder for `InitializeMarket` via CPI.
///
/// ### Accounts:
///
///   0. `[writable]` market_to_initialize
///   1. `[writable]` request_queue
///   2. `[writable]` event_queue
///   3. `[writable]` bids
///   4. `[writable]` asks
///   5. `[writable]` spl_token_account_coin
///   6. `[writable]` spl_token_account_price
///   7. `[]` coin_currency_mint
///   8. `[]` price_currency_mint
///   9. `[]` rent_sysvar
///   10. `[optional]` open_orders_market_authority
///   11. `[optional]` prune_authority
///   12. `[optional]` crank_authority
#[derive(Clone, Debug)]
pub struct InitializeMarketCpiBuilder<'a, 'b> {
    instruction: Box<InitializeMarketCpiBuilderInstruction<'a, 'b>>,
}

impl<'a, 'b> InitializeMarketCpiBuilder<'a, 'b> {
    pub fn new(program: &'b solana_account_info::AccountInfo<'a>) -> Self {
        let instruction = Box::new(InitializeMarketCpiBuilderInstruction {
            __program: program,
            market_to_initialize: None,
            request_queue: None,
            event_queue: None,
            bids: None,
            asks: None,
            spl_token_account_coin: None,
            spl_token_account_price: None,
            coin_currency_mint: None,
            price_currency_mint: None,
            rent_sysvar: None,
            open_orders_market_authority: None,
            prune_authority: None,
            crank_authority: None,
            coin_lot_size: None,
            pc_lot_size: None,
            fee_rate_bps: None,
            vault_signer_nonce: None,
            pc_dust_threshold: None,
            __remaining_accounts: Vec::new(),
        });
        Self { instruction }
    }
    /// the market to initialize
    #[inline(always)]
    pub fn market_to_initialize(
        &mut self,
        market_to_initialize: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.market_to_initialize = Some(market_to_initialize);
        self
    }
    /// zeroed out request queue
    #[inline(always)]
    pub fn request_queue(
        &mut self,
        request_queue: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.request_queue = Some(request_queue);
        self
    }
    /// zeroed out event queue
    #[inline(always)]
    pub fn event_queue(
        &mut self,
        event_queue: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.event_queue = Some(event_queue);
        self
    }
    /// zeroed out bids
    #[inline(always)]
    pub fn bids(&mut self, bids: &'b solana_account_info::AccountInfo<'a>) -> &mut Self {
        self.instruction.bids = Some(bids);
        self
    }
    /// zeroed out asks
    #[inline(always)]
    pub fn asks(&mut self, asks: &'b solana_account_info::AccountInfo<'a>) -> &mut Self {
        self.instruction.asks = Some(asks);
        self
    }
    /// spl-token account for the coin currency
    #[inline(always)]
    pub fn spl_token_account_coin(
        &mut self,
        spl_token_account_coin: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.spl_token_account_coin = Some(spl_token_account_coin);
        self
    }
    /// spl-token account for the price currency
    #[inline(always)]
    pub fn spl_token_account_price(
        &mut self,
        spl_token_account_price: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.spl_token_account_price = Some(spl_token_account_price);
        self
    }
    /// coin currency Mint
    #[inline(always)]
    pub fn coin_currency_mint(
        &mut self,
        coin_currency_mint: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.coin_currency_mint = Some(coin_currency_mint);
        self
    }
    /// price currency Mint
    #[inline(always)]
    pub fn price_currency_mint(
        &mut self,
        price_currency_mint: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.price_currency_mint = Some(price_currency_mint);
        self
    }
    /// the rent sysvar
    #[inline(always)]
    pub fn rent_sysvar(
        &mut self,
        rent_sysvar: &'b solana_account_info::AccountInfo<'a>,
    ) -> &mut Self {
        self.instruction.rent_sysvar = Some(rent_sysvar);
        self
    }
    /// `[optional account]`
    /// open orders market authority (optional)
    #[inline(always)]
    pub fn open_orders_market_authority(
        &mut self,
        open_orders_market_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    ) -> &mut Self {
        self.instruction.open_orders_market_authority = open_orders_market_authority;
        self
    }
    /// `[optional account]`
    /// prune authority (optional, requires open orders market authority)
    #[inline(always)]
    pub fn prune_authority(
        &mut self,
        prune_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    ) -> &mut Self {
        self.instruction.prune_authority = prune_authority;
        self
    }
    /// `[optional account]`
    /// crank authority (optional, requires prune authority)
    #[inline(always)]
    pub fn crank_authority(
        &mut self,
        crank_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    ) -> &mut Self {
        self.instruction.crank_authority = crank_authority;
        self
    }
    #[inline(always)]
    pub fn coin_lot_size(&mut self, coin_lot_size: u64) -> &mut Self {
        self.instruction.coin_lot_size = Some(coin_lot_size);
        self
    }
    #[inline(always)]
    pub fn pc_lot_size(&mut self, pc_lot_size: u64) -> &mut Self {
        self.instruction.pc_lot_size = Some(pc_lot_size);
        self
    }
    #[inline(always)]
    pub fn fee_rate_bps(&mut self, fee_rate_bps: u16) -> &mut Self {
        self.instruction.fee_rate_bps = Some(fee_rate_bps);
        self
    }
    #[inline(always)]
    pub fn vault_signer_nonce(&mut self, vault_signer_nonce: u64) -> &mut Self {
        self.instruction.vault_signer_nonce = Some(vault_signer_nonce);
        self
    }
    #[inline(always)]
    pub fn pc_dust_threshold(&mut self, pc_dust_threshold: u64) -> &mut Self {
        self.instruction.pc_dust_threshold = Some(pc_dust_threshold);
        self
    }
    /// Add an additional account to the instruction.
    #[inline(always)]
    pub fn add_remaining_account(
        &mut self,
        account: &'b solana_account_info::AccountInfo<'a>,
        is_writable: bool,
        is_signer: bool,
    ) -> &mut Self {
        self.instruction
            .__remaining_accounts
            .push((account, is_writable, is_signer));
        self
    }
    /// Add additional accounts to the instruction.
    ///
    /// Each account is represented by a tuple of the `AccountInfo`, a `bool` indicating whether the account is writable or not,
    /// and a `bool` indicating whether the account is a signer or not.
    #[inline(always)]
    pub fn add_remaining_accounts(
        &mut self,
        accounts: &[(&'b solana_account_info::AccountInfo<'a>, bool, bool)],
    ) -> &mut Self {
        self.instruction
            .__remaining_accounts
            .extend_from_slice(accounts);
        self
    }
    #[inline(always)]
    pub fn invoke(&self) -> solana_program_entrypoint::ProgramResult {
        self.invoke_signed(&[])
    }
    #[allow(clippy::clone_on_copy)]
    #[allow(clippy::vec_init_then_push)]
    pub fn invoke_signed(
        &self,
        signers_seeds: &[&[&[u8]]],
    ) -> solana_program_entrypoint::ProgramResult {
        let args = InitializeMarketInstructionArgs {
            coin_lot_size: self
                .instruction
                .coin_lot_size
                .clone()
                .expect("coin_lot_size is not set"),
            pc_lot_size: self
                .instruction
                .pc_lot_size
                .clone()
                .expect("pc_lot_size is not set"),
            fee_rate_bps: self
                .instruction
                .fee_rate_bps
                .clone()
                .expect("fee_rate_bps is not set"),
            vault_signer_nonce: self
                .instruction
                .vault_signer_nonce
                .clone()
                .expect("vault_signer_nonce is not set"),
            pc_dust_threshold: self
                .instruction
                .pc_dust_threshold
                .clone()
                .expect("pc_dust_threshold is not set"),
        };
        let instruction = InitializeMarketCpi {
            __program: self.instruction.__program,

            market_to_initialize: self
                .instruction
                .market_to_initialize
                .expect("market_to_initialize is not set"),

            request_queue: self
                .instruction
                .request_queue
                .expect("request_queue is not set"),

            event_queue: self
                .instruction
                .event_queue
                .expect("event_queue is not set"),

            bids: self.instruction.bids.expect("bids is not set"),

            asks: self.instruction.asks.expect("asks is not set"),

            spl_token_account_coin: self
                .instruction
                .spl_token_account_coin
                .expect("spl_token_account_coin is not set"),

            spl_token_account_price: self
                .instruction
                .spl_token_account_price
                .expect("spl_token_account_price is not set"),

            coin_currency_mint: self
                .instruction
                .coin_currency_mint
                .expect("coin_currency_mint is not set"),

            price_currency_mint: self
                .instruction
                .price_currency_mint
                .expect("price_currency_mint is not set"),

            rent_sysvar: self
                .instruction
                .rent_sysvar
                .expect("rent_sysvar is not set"),

            open_orders_market_authority: self.instruction.open_orders_market_authority,

            prune_authority: self.instruction.prune_authority,

            crank_authority: self.instruction.crank_authority,
            __args: args,
        };
        instruction.invoke_signed_with_remaining_accounts(
            signers_seeds,
            &self.instruction.__remaining_accounts,
        )
    }
}

#[derive(Clone, Debug)]
struct InitializeMarketCpiBuilderInstruction<'a, 'b> {
    __program: &'b solana_account_info::AccountInfo<'a>,
    market_to_initialize: Option<&'b solana_account_info::AccountInfo<'a>>,
    request_queue: Option<&'b solana_account_info::AccountInfo<'a>>,
    event_queue: Option<&'b solana_account_info::AccountInfo<'a>>,
    bids: Option<&'b solana_account_info::AccountInfo<'a>>,
    asks: Option<&'b solana_account_info::AccountInfo<'a>>,
    spl_token_account_coin: Option<&'b solana_account_info::AccountInfo<'a>>,
    spl_token_account_price: Option<&'b solana_account_info::AccountInfo<'a>>,
    coin_currency_mint: Option<&'b solana_account_info::AccountInfo<'a>>,
    price_currency_mint: Option<&'b solana_account_info::AccountInfo<'a>>,
    rent_sysvar: Option<&'b solana_account_info::AccountInfo<'a>>,
    open_orders_market_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    prune_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    crank_authority: Option<&'b solana_account_info::AccountInfo<'a>>,
    coin_lot_size: Option<u64>,
    pc_lot_size: Option<u64>,
    fee_rate_bps: Option<u16>,
    vault_signer_nonce: Option<u64>,
    pc_dust_threshold: Option<u64>,
    /// Additional instruction accounts `(AccountInfo, is_writable, is_signer)`.
    __remaining_accounts: Vec<(&'b solana_account_info::AccountInfo<'a>, bool, bool)>,
}
